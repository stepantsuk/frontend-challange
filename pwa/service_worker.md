# Service Worker
___
## Что такое Service Worker?
- Во-первых, это скрипт, который браузер запускает в фоновом режиме, отдельно от страницы, открывая дверь для возможностей, не требующих веб-страницы или взаимодействия с пользователем.
- Во-вторых, SW запускается в worker контексте, поэтому он не имеет доступа к DOM и работает в потоке, отдельном от основного потока JavaScript, управляющего вашим приложением, а следовательно — не блокирует его. Он призван быть полностью асинхронным, поэтому использовать синхронные API (XHR и LocalStorage) в SW нельзя.
- В-третьих, из соображений безопасности SW работают только по HTTPS, так как давать посторонним людям возможность изменять сетевые запросы крайне опасно.

Service worker фактически выполняет роль прокси-сервера, находящегося между веб-приложением и браузером, а также сетью (если доступна). Он позволяет (кроме прочего) описывать корректное поведение веб-приложения в режиме офлайн, перехватывать запросы сети и принимать соответствующие меры, основываясь на доступности сети, и обновлять данные, находящиеся на сервере при доступе к нему. Также они имеют доступ к push-уведомлениям и API для фоновой синхронизации.

**Service worker** — это событийно-управляемый worker, регистрируемый на уровне источника и пути. **Он представляет собой JavaScript-файл**, который может контролировать веб-страницу/сайт, с которым он ассоциируется, перехватывать и модифицировать запросы навигации и ресурсов, очень гибко кешировать ресурсы, для того чтобы предоставить вам полный контроль над тем, как приложение ведёт себя в определённых ситуациях (например, когда сеть не доступна). **Ключевая особенность**: он не имеет прямого доступа к DOM, но может коммуницировать с вкладками через postMessage. Работает только по HTTPS (или localhost).»

Service Worker будет следовать следующему **жизненному циклу**:
- Загрузка. Браузер скачивает .js файл.
- Установка.
    - Срабатывает, если файл новый (изменился по сравнению с предыдущим).
    - Идеальный момент для кэширования статики (App Shell).
    - Если на этом этапе произошла ошибка (например, не удалось скачать файл), SW не активируется.
- Ожидание.
    - Новый SW не активируется, пока старая версия контролирует вкладки. Решение: Использовать self.skipWaiting() в install, чтобы форсировать активацию.
- Активация.
    - Идеальный момент для чистки старого кэша. Важно: По умолчанию SW активируется, но не захватывает контроль над уже открытыми вкладками. Нужно вызвать clients.claim().
- Idle/Fetch (Бездействие/Перехват): Работает как прокси.

**События** в Service Worker:
- install (подготовка кэша).
- activate (чистка кэша, захват клиентов).
- fetch (самое важное — перехват запросов).
- push (Push-уведомления с сервера).
- sync (фоновая синхронизация при восстановлении соединения).
- message (коммуникация с вкладкой).

**Стратегии** кэширования
- Cache First: Сначала в кэш, нет — в сеть. (Идеально для логотипов, CSS, JS).
- Network First: Сначала в сеть, упала — из кэша. (Идеально для новостей, контента).
- Stale-While-Revalidate: Отдаем быстро из кэша, но одновременно обновляем в фоне. (Лучшее для UX).
- Network Only: Только сеть.
- Cache Only: Только кэш.
___
## Важное
**Почему Service Worker требует HTTPS?** - Потому что это огромная власть (MITM-атака). Если злоумышленник внедрит свой SW, он сможет контролировать весь трафик пользователя (логины, пароли). HTTPS гарантирует, что код не был изменен по пути.

**Может ли Service Worker работать, когда вкладка закрыта?** - Да, Push-уведомления и фоновая синхронизация (sync) могут «разбудить» SW, даже если сайт не открыт.

**В чем отличие Service Worker от Web Worker?**
- Web Worker: Создается для тяжелых вычислений, живет пока жива вкладка, имеет доступ к AJAX, не имеет доступа к DOM.
- Service Worker: Прокси-сервер, живет независимо от вкладки, не имеет доступа к синхронному XHR/localStorage (только IndexedDB), перехватывает запросы.

___
## ИТОГО
- Это прокси на базе событий, работающий воркером вне потока.
- Живет по циклу: Register -> Install (кэш) -> Waiting -> Activate (cleanup) -> Fetch.
- Позволяет реализовать PWA, офлайн, кастомные стратегии кэша.
- Требует HTTPS.
- Осторожно: нужно управлять активацией (skipWaiting/claim) и обновлением кэша, чтобы пользователь не видел старую версию приложения.
- Современные фреймворки (Next.js, Angular) часто генерируют SW автоматически, но понимание его работы критично для дебага проблем с кэшем на проде.

```js
// register
// В основном потоке (main.js)
if ('serviceWorker' in navigator) {
  window.addEventListener('load', async () => {
    try {
      const registration = await navigator.serviceWorker.register('/sw.js');
      console.log('SW registered:', registration.scope);
    } catch (e) {
      console.error('SW registration failed:', e);
    }
  });
}
```

```js
// В файле sw.js

// кэширование в install
const CACHE_NAME = 'my-site-cache-v1';
const urlsToCache = ['/', '/styles.css', '/script.js'];

self.addEventListener('install', (event) => {
  // waitUntil гарантирует, что SW не перейдет в стадию activate, пока кэш не готов
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => cache.addAll(urlsToCache))
  );
});

self.addEventListener('activate', (event) => {
  console.log('Активирован');
});

self.addEventListener('fetch', (event) => {
  console.log('Происходит запрос на сервер');
});
```

