# Что такое ООП

Объектно-ориентированная идеология разрабатывалась как попытка связать поведение сущности с её данными и спроецировать объекты реального мира и бизнес-процессов в программный код.
#### Ассоциация
В полях объекта могут храниться не только обычные переменные стандартных типов, но и другие объекты. А эти объекты могут в свою очередь хранить какие-то другие объекты и так далее, образуя дерево (иногда граф) объектов. Это отношение называется ассоциацией.

Один объект стал составной частью другого объекта. Это и есть ассоциация. Она в свою очередь бывает двух видов:
1. **Композиция** — жизненный цикл дочернего объекта совпадает с жизненным циклом родительского.
2. **Агрегация** — жизненный цикл дочернего объекта не зависит от жизненного цикла родительского, и может использоваться другими объектами
#### Фундаментальная троица
- **инкапсуляция**,
- **полиморфизм**,
- **наследование**,
##### **Наследование**
это механизм системы, который позволяет, как бы парадоксально это не звучало, наследовать одними классами свойства и поведение других классов для дальнейшего расширения или модификации.
Если же в классе-потомке переопределить уже существующий метод в классе-родителе, то сработает перегрузка. Это позволяет не дополнять поведение родительского класса, а модифицировать.

Как при описании отношений двух сущностей определить, когда уместно наследование, а когда — композиция? Можно воспользоваться популярной шпаргалкой: спросите себя, **сущность А является сущностью Б**? Если да, то скорее всего, тут подойдет наследование. Если же **сущность А является частью сущности Б**, то наш выбор — композиция.

Возможность наследоваться от нескольких классов вместо одного — это множественное наследование. это грех, оно несет за собой ромбовидную проблему и неразбериху с конструкторами. задачи, которые решаются множественным наследованием, можно решать другими механизмами, например, механизмом интерфейсов. Но справедливости ради, следует отметить, что множественное наследование удобно использовать для реализации примесей.

**Абстрактные классы** - От обычных классов они отличаются тем, что нельзя создать объект такого класса. Он нужен для того, чтобы от него могли наследоваться потомки — обычные классы, объекты которых уже можно создавать. Абстрактный класс наряду с обычными методами содержит в себе абстрактные методы без имплементации (с сигнатурой, но без кода), которые обязан имплементировать программист, задумавший создать класс-потомок. Абстрактные классы не обязательны, но они помогают установить контракт, обязующий имплементировать определенный набор методов, дабы уберечь программиста с плохой памятью от ошибки имплементации.
##### **Полиморфизм**
Это свойство системы, позволяющее иметь множество реализаций одного интерфейса. Ничего непонятно. Обратимся к трансформерам. Польза полиморфизма в данном примере заключается в том, что код игры ничего не знает о реализации его просьбы, кто как должен атаковать, его задача просто вызвать метод attack(), сигнатура которого одинакова для всех классов персонажей. Это позволяет добавлять новые классы персонажей, или менять методы существующих, не меняя код игры
##### **Инкапсуляция**
это контроль доступа к полям и методам объекта. Под контролем доступа подразумевается не только можно/неможно, но и различные валидации, подгрузки, вычисления и прочее динамическое поведение.

Во многих языках частью инкапсуляции является сокрытие данных. Для этого существуют модификаторы доступа (опишем те, которые есть почти во всех ООП языках):
- publiс — к атрибуту может получить доступ любой желающий
- private — к атрибуту могут обращаться только методы данного класса
- protected — то же, что и private, только доступ получают и наследники класса в том числе
  Геттеры и сеттеры — это методы, задача которых контролировать доступ к полям. Геттер считывает и возвращают значение поля, а сеттер — наоборот, принимает в качестве аргумента значение и записывает в поле. Это дает возможность снабдить такие методы дополнительными обработками. Например, сеттер при записи значения в поле объекта, может проверить тип, или входит ли значение в диапазон допустимых (валидация). В геттер же можно добавить, ленивую инициализацию или кэширование, если актуальное значение на самом деле лежит в базе данных. Применений можно придумать множество.

#### Интерфейсы
Задача интерфейса — снизить уровень зависимости сущностей друг от друга, добавив больше абстракции.

Интерфейс очень смахивает на абстрактный класс, но является не классом, а просто пустышкой с перечислением абстрактных методов (без имплементации). Другими словами, интерфейс имеет декларативную природу, то есть, чистый контракт без капельки кода.

Обычно в языках, в которых есть интерфейсы, нет множественного наследования классов, но есть множественное наследование интерфейсов. Это позволяет классу перечислить интерфейсы, которые он обязуется имплементировать.

У интерфейса двустороннее применение:
1. По одну сторону интерфейса — классы, имплементирующие данный интерфейс.
2. По другую сторону — потребители, которые используют этот интерфейс в качестве описания типа данных, с которым они (потребители) работают.






